#include "halde.h"
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/// Magic value for occupied memory chunks.
#define MAGIC ((void*)0xbaadf00d)

/// Size of the heap (in bytes).
#define SIZE (1024*1024*1)		//2^20 B = 1 MiB

/// Memory-chunk structure.
struct mblock {
	struct mblock *next;
	size_t size;
	char memory[];		//address of the current mblock
};

/// Heap-memory area.
static char memory[SIZE]; 	//the whole memory area

/// Pointer to the first element of the free-memory list.
static struct mblock *head;

/// Helper function to visualise the current state of the free-memory list.
void printList(void) {
	struct mblock *lauf = head;

	// Empty list
	if (head == NULL) {
		char empty[] = "(empty)\n";
		write(STDERR_FILENO, empty, sizeof(empty));
		return;
	}

	// Print each element in the list
	const char fmt_init[] = "(off: %7zu, size:: %7zu)";
	const char fmt_next[] = " --> (off: %7zu, size:: %7zu)";
	const char * fmt = fmt_init;
	char buffer[sizeof(fmt_next) + 2 * 7];

	while (lauf) {
		size_t n = snprintf(buffer, sizeof(buffer), fmt
			, (uintptr_t) lauf - (uintptr_t)memory, lauf->size);
		if (n) {
			write(STDERR_FILENO, buffer, n);
		}

		lauf = lauf->next;
		fmt = fmt_next;
	}
	write(STDERR_FILENO, "\n", 1);
}

void *malloc (size_t size) {
	// TODO: implement me!

	//malloc(0): return NULL
	if (size == 0) {
		return NULL;
	}

	//the heap area is not yet intitialized / or the heap space is not enough
	if (head == NULL) {
		//casting the memory, check if the beginning is empty
		struct mblock* help = (struct mblock*) memory;
		//check if allocation is ever implemented
		if (help->next != MAGIC) {
			//nope
			help->size = SIZE - sizeof(struct mblock);
			help->next = NULL;
			//update the head
			head = help;	
		}
	}

	//create lauf to run over the list
	struct mblock* lauf = head;
	//prev_next = head ptr in Uebung
	struct mblock** prev_next = &head;

	//iterate over the list (all the mblocks), if lauf->size < size, read the next mblock
	while (lauf != NULL && lauf->size < size) {
		prev_next = &(lauf->next);
		lauf = *prev_next;
	}

	//case 1: the list is iterated and not a enough big hole is found
	if (lauf == NULL) {
		errno = ENOMEM;
		return NULL;
	}

	//case 2: the left hole is not enough for building a structure
	if (lauf->size - size < sizeof(struct mblock)) {
		//kick the lauf block out from the list
		*prev_next = lauf->next;

	} 
	//case 3: the rest is enough for the mblock structure and the allocation space
	else {
		//create a new mblock, casting the rest of the memory into a mblock
		struct mblock* new = (struct mblock*) (lauf->memory + size); 	//add + offset
		new->size = lauf->size - size - sizeof(struct mblock);
		new->next = lauf->next;

		*prev_next = new;
	}

	lauf->next = MAGIC;
	return lauf->memory;
}

void free (void *ptr) {
	// TODO: implement me!
	if (ptr == NULL) {
		return ;
	}
	//free the given mblock
	/* 
	 * | struct mblock | storage |
	 * ^mbp			   ^ptr
	 */
	struct mblock* mbp = (struct mblock*) (ptr - sizeof(struct mblock)); 	//address - offset

	//check MAGIC value
	if (mbp->next == MAGIC) {
		//make the next to the list head
		mbp->next = head;	
		head = mbp;	//change the position of mbp and head
	}
	//if the mbp->next != MAGIC: mbp/ptr is not generated by malloc, abort the program
	abort();
}

void *realloc (void *ptr, size_t size) {
	// TODO: implement me!
	//if ptr = NULL, realloc = malloc
	if (ptr == NULL) {
		return malloc(size);
	}
	//size = 0, realloc = free
	else if (size == 0) {
		free(ptr);
		return NULL;
	}

	//realloc has 2 directions: 1) enlarge allocation, 2) schrink the allocation
	//allocate a new mblock by malloc
	void* new_ptr = malloc(size);	
	//error by malloc
	if (new_ptr == NULL) {
		return NULL;
	}

	//create mblock mbp on the target ptr
	/* 
	 * | struct mblock | storage |
	 * ^mbp			   ^ptr
	 */
	struct mblock* mbp = (struct mblock*) (ptr - sizeof(struct mblock)); 	//address - offset

	size_t smaller_size = mbp->size;

	//compare the smaller_size with parameter size
	if (smaller_size > size) {
		//take the smaller size of two
		smaller_size = size;
	}

	//copy the smaller memory
	new_ptr = memcpy(new_ptr, ptr, smaller_size);

	//free the ptr (old/to be adjust storage)
	free(ptr);

	//return the new allocated storage
	return new_ptr;
}

void *calloc (size_t nmemb, size_t size) {
	// TODO: implement me!
	//total size of the list
	size_t size_arr = nmemb * size;		//could overflow the size_t
	//overflow
	if (size != 0 && (size_arr / size != nmemb)) {
		//set errno: not enough memory
		errno = ENOMEM;
		return NULL;
	}

	//allocate
	void* ptr = malloc(size_arr);

	//successful
	if (ptr != NULL) {
		memset(ptr, 0, size_arr);
		return ptr;
	}
	//error by malloc
	return NULL;
}
